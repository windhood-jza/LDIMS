# LDIMS 新功能实现规划

本文档基于 `新功能规划.md`，旨在为 LDIMS 系统新增的多项核心功能（多文件支持、智能内容提取、可配置存储、MCP 服务器接口）提供一个分阶段、详细的实现计划。

**实施优先级:**

1.  **核心多文件上传与管理功能 (异步流程)**
2.  **后台内容提取 (MarkItDown + OCR) 与展示 (注意：提取内容仅用于 LLM)**
3.  **独立 MCP 服务器实现与 LLM 集成接口**

---

## 阶段一：核心多文件上传与管理功能 (异步流程)

**目标:** 实现用户先创建文档元数据，然后可以异步、分批（但遵循整体替换原则）上传关联文件，并手动触发后续处理。此阶段**不包含**实际的内容提取处理，但**前端展示**需要按最终效果设计（预览原始文件）。

**1. 数据库准备 (必需最先完成):**

- ✅ **执行 SQL 变更:**
  - ✅ 在数据库中执行 `新功能规划.md` 中定义的 SQL 操作指令：
    - ✅ 创建 `document_files` 表 (包含 `sequence` 字段, `processing_status` 初始默认值改为 `pending`)。
    - ✅ 为 `document_files.extracted_content` 添加**全文索引**。
    - ✅ 向 `system_configs` 表插入 `FILE_STORAGE_PATH` 配置项。
  - ✅ **验证:** 确认表结构和配置项已正确创建。
  - ✅ _SQL 微调:_ `document_files` 的 `processing_status` 默认值改为 `pending`。
    ```sql
    -- ... 创建 document_files 表 ...
    `processing_status` ENUM('pending', 'processing', 'completed', 'failed', 'ocr_fallback') NOT NULL DEFAULT 'pending' COMMENT '内容处理状态',
    -- ... 其他不变 ...
    ```

**2. 后端 (LDIMS 核心) 实现:**

- ✅ **模型层更新:**
  - ✅ 使用 Sequelize CLI 或手动创建 `DocumentFile` 模型 (`src/models/DocumentFile.ts`)，包含 `新功能规划.md` 中定义的所有字段 (`id`, `document_id`, `file_name`, `file_path`, `file_type`, `file_size`, `sequence`, `extracted_content`, `processing_status`, `created_at`, `updated_at`)。
  - ✅ 定义 `Document` 与 `DocumentFile` 的一对多关联 (`Document.hasMany(DocumentFile)`) 和反向关联 (`DocumentFile.belongsTo(Document)`)。
  - ✅ 确保关联在 `models/index.ts` 中被正确调用/定义。
- ✅ **配置读取与存储逻辑:**
  - ✅ 实现读取 `system_configs` 表中 `FILE_STORAGE_PATH` 的逻辑（例如，在 `src/config/storage.ts` 或类似模块中）。提供安全的默认路径。
  - ✅ 配置 `multer` 中间件 (`src/middleware/documentUpload.ts`):
    - ✅ 使用配置好的存储路径作为根目录 (`getDocumentStoragePath`)。
    - ✅ 配置 `multer.diskStorage`：目标目录为 `[根路径]/[净化后的文档名]/` (需要动态生成)，文件名先使用临时唯一名 (如 UUID)。
    - ✅ 配置 `multer.array('files', ...)`。
    - ✅ 设置合理的文件大小和类型限制。
- ✅ **API 端点实现/修改:**
  - ✅ **`POST /api/v1/documents` (创建文档元数据):**
    - ✅ 定义路由 (`src/routes/document.ts`)。
    - ✅ 实现控制器函数 (`src/controllers/documentController.ts#createDocumentMetadata`)。
    - ✅ 应用认证/权限中间件。
    - ✅ 添加请求体验证 (JSON, 必须字段如 `docName`, `submitter`, `receiver` 等)。
    - ✅ 调用 `DocumentService.createDocument` 方法 (传递元数据和 `req.user.name` 或类似的用户信息)。
    - ✅ 处理服务层错误 (如验证失败、数据库错误)。
    - ✅ 成功时返回 201 状态码和创建的文档信息 (包含 ID)。
  - ✅ **`PUT /api/v1/documents/:id` (更新文档元数据):**
    - ✅ 定义路由。
    - ✅ 实现控制器函数 (`src/controllers/documentController.ts#updateDocumentMetadata`)。
    - ✅ 应用认证/权限中间件。
    - ✅ 添加路径参数 (`id`) 和请求体验证。
    - ✅ 调用 `DocumentService.updateDocument` 方法 (传递 ID, 元数据, `req.user.name`)。
    - ✅ 处理服务层错误 (如文档未找到、验证失败)。
    - ✅ 成功时返回 200 状态码和更新后的文档信息。
  - ✅ **`POST /api/v1/documents/:id/files` (上传/替换关联文件):**
    - ✅ 定义路由。
    - ✅ 实现控制器函数 (`src/controllers/documentController.ts#uploadDocumentFiles`)。
    - ✅ 应用认证/权限中间件。
    - ✅ **应用 `documentUploadMiddleware` 处理 `multipart/form-data` 和 'files' 字段。**
    - ✅ 添加路径参数 (`id`) 验证 (确保是数字)。
    - ✅ 检查 `req.files` 是否存在且为数组 (Multer 会处理空上传，但最好确认)。
    - ✅ **调用 `DocumentService.uploadAndReplaceFiles` 方法 (传递 `id` 和 `req.files` 数组)。**
    - ✅ 处理服务层错误 (如文档未找到、文件保存/删除失败、数据库事务错误)。
    - ✅ 处理 Multer 中间件可能产生的错误 (如文件过大、类型不符 - 通过全局错误处理或在此捕获)。
    - ✅ 成功时返回 200 状态码和新文件列表信息 (或仅成功消息)。
  - ✅ **`(可选) DELETE /api/v1/documents/:id/files` (清空关联文件):**
    - ✅ 决定是否实现此端点 (已决定实现)。
    - ✅ 定义路由 (如果实现)。
    - ✅ 实现控制器函数 (`DocumentController.ts#deleteAllDocumentFiles`) (如果实现)。
    - ✅ 应用认证/权限中间件 (如果实现)。
    - ✅ 添加路径参数 (`id`) 验证 (如果实现)。
    - ✅ 调用 `DocumentService.deleteAllFilesForDocument` 方法 (传递 `id`) (如果实现)。
    - ✅ 处理服务层错误 (如文档未找到) (如果实现)。
    - ✅ 成功时返回 204 (No Content) 或 200 状态码 (如果实现)。
  - ✅ **`POST /api/v1/documents/:id/start-processing` (触发文件处理):**
    - ✅ 定义路由。
    - ✅ 实现控制器函数 (`src/controllers/DocumentController.ts#startFileProcessing`)。
    - ✅ 应用认证/权限中间件。
    - ✅ 添加路径参数 (`id`) 验证。
    - ✅ 调用 `DocumentService.triggerFileProcessing` 方法 (传递 `id`)。
    - ✅ 处理服务层错误 (如文档未找到、任务入队失败)。
    - ✅ 成功时返回 202 (Accepted) 或 200 状态码，表示处理已接受/开始。
  - ✅ **`GET /api/v1/files/:file_id/download` (下载单个文件):**
    - ✅ 定义路由。
    - ✅ 实现控制器函数 (`src/controllers/DocumentController.ts#downloadDocumentFile`)。
    - ✅ 应用认证/权限中间件。
    - ✅ 添加路径参数 (`file_id`) 验证。
    - ✅ 调用服务层方法获取文件信息 (如 `DocumentFile.findByPk(file_id)`)，包含 `filePath` (相对路径) 和 `fileName` (原始文件名)。
    - ✅ 处理文件记录未找到的错误 (返回 404)。
    - ✅ 使用 `getStoragePath` 获取存储根路径。
    - ✅ 使用存储根路径和 `filePath` 拼接完整的文件物理路径。
    - ✅ 使用 `res.download()` 提供文件下载，传递完整物理路径和**原始文件名 (`fileName`)**。
    - ✅ 处理读取物理文件时的错误 (返回 500)。
  - ✅ **`PUT /api/v1/system/config` (更新系统配置 - 确保兼容):**
    - ✅ 检查现有系统配置路由 (`src/routes/system.ts`) 和控制器 (`src/controllers/systemController.ts`)。
    - ✅ 确保应用了合适的管理员权限中间件。
    - ✅ 确认或添加请求体验证（检查 `configKey` 和 `configValue`）。
    - ✅ 调用 `SystemConfigService` (或直接在控制器中) 更新或创建配置项。
    - ✅ **添加逻辑:** 如果更新的 `configKey` 是 `FILE_STORAGE_PATH`，则调用 `clearCachedStoragePaths()` (来自 `src/config/storage.ts`)。
    - ✅ 处理错误。
    - ✅ 返回成功响应。
- ✅ **服务层 (`DocumentService`) 调整:**
  - ✅ **调整 `getDocumentById` 方法:**
    - ✅ 修改查询，使用 `include` 选项 (Eager Loading) 加载关联的 `DocumentFile` 模型。
    - ✅ 确保关联的 `DocumentFile` 按 `sequence` 字段升序排列。
  - ✅ **调整 `listDocuments` 方法:**
    - ✅ 分析前端列表页是否需要关联文件的聚合信息（数量）。
    - ✅ 修改查询以包含关联文件数量 (`fileCount`)。

**3. 前端 (LDIMS Vue App) 实现:**

- ✅ **API 服务层 (`src/services/api/document.ts`):**

  - ✅ 更新 `createDocument` 和 `updateDocument` 方法签名和实现以匹配后端 API (确认无需修改)。
  - ✅ 新增 `uploadFiles(documentId, formData)` 方法。
  - ✅ 新增 `deleteAllFiles(documentId)` 方法。
  - ✅ 新增 `startProcessing(documentId)` 方法。
  - ✅ 新增 `downloadFile(fileId)` 方法 (并实现 `downloadBlob` 辅助函数)。
  - ✅ **新增 `getFilePreviewBlob(fileId)` 方法 (用于获取图片预览) **。

- ✅ **系统设置页面 (`views/SettingsView.vue`):**

  - ✅ **获取配置:** 在页面加载时，调用后端 API 获取 `FILE_STORAGE_PATH` 的当前值。
  - ✅ **UI 实现:** 添加表单项，用于显示和编辑该路径。
  - ✅ **保存逻辑:** 添加保存按钮，调用后端 API 更新配置。
  - ✅ **API 服务层 (`src/services/api/system.ts`):** 添加获取和更新系统配置的 API 调用函数。

- ✅ **文档创建/编辑流程调整 (`components/DocumentFormDialog.vue`):**

  - ✅ **状态管理:**
    - ✅ 添加响应式状态：`currentId`, `formData`, `associatedFiles` (原 `files`), `isMetadataSaved`, `filesToUpload`。
  - ✅ **`open` 方法修改:**
    - ✅ 接收 `mode` 和 `data`。
    - ✅ 正确处理 'add' 模式重置。
    - ✅ 正确处理 'edit'/'view' 模式填充。
    - ✅ 正确设置 `isMetadataSaved = true`。
  - ✅ **元数据保存逻辑 (`handleSubmit`):**
    - ✅ 调用 `createDocument` 或 `updateDocument` API。
    - ✅ 成功后显示消息、关闭弹窗、触发 `success` 事件。
  - ✅ **文件管理区域 (列表、上传、清空):**
    - ✅ **显示当前文件列表 (`el-table`):** 列、数据、下载按钮。
    - ✅ **上传组件 (`el-upload`):** 配置、`v-model` 绑定、事件处理、提示。
    - ✅ **手动上传触发按钮 ("上传选中文件"):** 显示/禁用、调用 API、刷新列表。
    - ✅ **清空按钮 ("清空所有文件"):** 显示/禁用、调用 API、刷新列表。
    - ✅ **处理按钮 ("开始处理文件"):** 按钮已移除，逻辑整合到 `handleSubmit` 自动触发。

- ✅ **文件预览/查看对话框 (`components/DocumentFileViewDialog.vue`):**

  - ✅ **布局:** 卡片式画廊或列表。
  - ✅ **卡片内容:** 文件元数据、下载按钮。
  - ✅ **文件预览/访问区域 (根据 `file.fileType` 条件渲染):**
    - ✅ **图片 (jpg, png):** 使用卡片缩略图 + `<el-image-viewer>` 大图预览。
    - ✅ **PDF:** 提供在新标签页打开预览。
      - ✅ **实现方案:** 使用 `pdfjs-dist` 库在对话框内渲染 PDF。
      - ✅ **步骤:**
        - ✅ 安装 `pdfjs-dist`。
        - ✅ **Worker 配置:**
          - ✅ **尝试 1 (Import):** 动态导入 `pdf.worker.min.js`，失败 (Vite 动态导入问题)。
          - ✅ **尝试 2 (CDN):** 不适用 (本地文件)。
          - ✅ **尝试 3 (Fake Worker):** 设置 `workerSrc=''` 或 `disableWorker=true`，失败 (API 不存在或不可扩展)。
          - ✅ **尝试 4 (Public, .js):** 复制 `pdf.worker.min.js` 到 `public` 目录，设置 `GlobalWorkerOptions.workerSrc = '/pdf.worker.min.js'`，失败 (404 或 MIME type)。
          - ✅ **尝试 5 (Public, new URL):** 使用 `new URL(...)` 构造 Worker 路径，Worker 加载成功但渲染失败。
          - ✅ **尝试 6 (Public, .mjs):** 复制 `pdf.worker.min.mjs` (根据版本推断) 到 `public` 目录，**直接设置 `GlobalWorkerOptions.workerSrc = '/pdf.worker.min.mjs'` 成功加载 Worker**。
        - ✅ **UI 添加:** 添加 PDF 工具栏 (页码、翻页、缩放按钮) 和 `<canvas>` 用于渲染。
        - ✅ **加载与渲染逻辑:**
          - ✅ 实现 `loadPdfPreview(fileId)` 函数：调用 API 获取 PDF Blob，使用 `pdfjsLib.getDocument({ data: pdfData.value }).promise` 加载文档。
          - ✅ 实现 `renderPage(pageNumber)` 函数：获取 PDF 页面，配置视口 (viewport)，在 Canvas 上下文中渲染。
        - ✅ **Vue Proxy 问题:** 渲染时出现 `TypeError: Cannot read from private field`。
          - ✅ **原因分析:** Vue 3 的响应式系统 (Proxy) 与 PDF.js 内部对象 (包含私有字段) 冲突。
          - ✅ **解决方案:** 使用 `shallowRef` 来包装 `pdfDocument` 对象，避免 Vue 对其进行深度代理。`const pdfDocument = shallowRef(null);`
        - ✅ **功能实现:** 添加翻页、缩放逻辑。
    - ✅ **Office 文档 (docx, xlsx, pptx 等):** 显示 "下载后查看" 提示/链接。
    - ✅ **其他未知类型:** 显示 "下载后查看" 提示/链接。

- ✅ **文档列表页 (`views/DocumentListView.vue`):**

  - ✅ **表格列定义:**
    - ✅ 保留核心元数据列。
    - ✅ **新增 "关联文件数" 列 (基于 `row.fileCount`)。**
    - ✅ **操作列按钮调整:**
      - ✅ "查看" 按钮: 打开 `DocumentFormDialog` (view 模式, 仅元数据)。
      - ✅ "编辑" 按钮: 打开 `DocumentFormDialog` (edit 模式, 元数据+文件管理)。
      - ✅ **新增 "预览文件" 按钮:** 点击调用 `handlePreviewFiles(row)` 打开 `DocumentFileViewDialog`。
      - ✅ "删除" 按钮: (保持不变)。
  - ✅ **添加处理函数:**
    - ✅ `handlePreviewFiles(row)`。
    - ✅ `handleEdit(row)`。
    - ✅ `handleView(row)`。

---

## 阶段二：后台内容提取 (MarkItDown + OCR) 与展示 (注意：提取内容仅用于 LLM)

**目标:** 实现对上传的每个文件进行后台智能内容提取，**根据文件类型选择合适的处理方式 (MarkItDown 或 OCR)**，并将结果存储在 `document_files.extracted_content` 字段中，供后续 LLM 使用。前端**不直接展示**这部分内容。

**1. 后端 (LDIMS 核心) 实现:**

- ✅ **[环境与依赖]**
  - ✅ 确认并配置 Redis 服务及其连接信息。
  - ✅ 安装 `bullmq` 依赖库。
  - ✅ **[修改]** 准备 Python 运行环境，确保安装:
    - ✅ `markitdown` 库及其处理 Word (`[docx]`), PDF (`[pdf]`) 所需的依赖项。
    - ✅ **[新增]** 安装 **PaddleOCR** 及其依赖库 (`paddlepaddle`, `paddleocr` 等)。
  - ✅ **[移除/可选]** 不再强制依赖 Azure Document Intelligence (`[az-doc-intel]`)，除非明确选择它作为 OCR 备选。
- ✅ **[配置]** (保持不变，除非选择 Azure DI)
- ✅ **[`bullmq` 队列设置 (用于内容提取)]** (保持不变)
- ⏳ **[`bullmq` Worker 设置 (用于内容提取)]** (保持不变)
- ✅ **[Node.js <-> Python 交互层]**
  - ✅ 开发或完善用于从 Node.js 调用外部 Python 脚本的通用工具模块 (`pythonExecutor.ts`)。
  - ✅ **[修改]** 确保该模块能够调用**不同**的 Python 脚本（一个用于 MarkItDown，一个用于 PaddleOCR）或**同一个**能根据文件类型分发任务的脚本。
  - ✅ 确保能安全传递文件路径参数。
  - ✅ 定义返回结果（成功/失败、提取的 Markdown、错误信息）。
  - ✅ 加入超时控制。
- ❌ **[内容提取服务逻辑 (被 Worker 调用)]** (**逻辑重大调整**)
  - ❌ 实现或修改内容提取服务的主处理函数 (`ContentProcessingService.ts#processContentExtractionTask`)。
  - ❌ 在主处理函数中，依次完成以下任务：
    - ❌ 根据文件 ID 获取文件记录 (包含 `file_type` 或根据文件名判断)。
    - ❌ 获取文件的物理存储路径。
    - ❌ **根据文件类型决定调用哪个 Python 脚本/逻辑:**
      - ❌ **如果是 `.docx` 或简单 `.pdf` (可配置策略):** 调用执行 **MarkItDown** 处理的 Python 脚本/逻辑。
      - ❌ **如果是图像文件 (`.jpg`, `.png`, `.tiff` 等) 或复杂/扫描版 `.pdf`:** 调用执行 **PaddleOCR** 处理的 Python 脚本/逻辑。
    - ❌ 根据调用的 Python 脚本/逻辑的执行结果，更新数据库中文件的 `extracted_content` 和 `processing_status` 字段。
      - ❌ 处理 MarkItDown 可能的 `UnsupportedFormatException` (如遇到 `.doc` 文件)。
      - ❌ 处理 PaddleOCR 可能返回的空结果（无文本）或错误。
- ❌ **[API 端点修改 (`start-processing`)]** (逻辑保持不变，仍然是为文件添加任务到队列)

**2. Python 环境与脚本:** (**重大修改**)

- ✅ **[环境准备]**
  - ✅ 准备 Python 运行环境 (推荐使用虚拟环境 `venv`)。
  - ✅ 在虚拟环境中安装 `markitdown` 及其 `[docx]`, `[pdf]` extras。
  - ✅ **[新增]** 在虚拟环境中安装 `paddlepaddle` 和 `paddleocr`。
- ✅ **[脚本开发/调用方式]**
  - ✅ **[方案 A: 单一分发脚本 (推荐)]** 创建一个主 Python 脚本 (例如 `process_document.py`)：
    - ✅ 接收文件路径作为参数。
    * ✅ 内部根据文件扩展名或使用 `python-magic` 等库判断文件类型。
    * ✅ 如果是 Word/PDF 类型，调用 `markitdown` 库进行处理。
    * ✅ 如果是 Image 类型，调用 `PaddleOCR` 库进行 OCR 处理，并将结果（通常是 `[bbox, (text, score)]` 列表）转换为 Markdown 格式 (例如，简单地将所有文本行连接起来)。
    * ✅ 将提取的 Markdown 输出到 stdout，错误信息输出到 stderr。
  - ❌ **[方案 B: 多个独立脚本]** 保留 `markitdown_script.py` 处理 Word/PDF，并创建一个新的 `paddleocr_script.py` 处理图像。
    - ❌ Node.js 端需要根据文件类型决定调用哪个脚本。

**3. 前端 (LDIMS Vue App) 实现:** (保持不变)

- ❌ **内容展示:** 无需变更。
- ❌ **列表页:** 无需变更。

---

## 阶段三：独立 MCP 服务器实现与 LLM 集成接口

**目标:** (同前)

**1. 后端 (LDIMS 核心) 实现:** (同前，确保内部 API 正确返回包括 `extracted_content` 在内的数据)

**2. MCP 服务器 (独立 Node.js/TypeScript 项目) 实现:** (同前，能力处理函数调用内部 API 获取数据，特别是 `extracted_content`)

**3. 部署:** (同前)

---

## 贯穿各阶段的任务

- ❌ **测试:** (同前，增加对文件存储结构、命名、截断、下载文件名的测试)
- ❌ **错误处理:** (同前，增加文件名处理、文件重命名、文件夹操作相关的错误处理)
- ❌ **文档:** (同前，更新存储和命名约定)
- ❌ **安全性:** (同前，确保文件名净化和路径处理的安全性)
