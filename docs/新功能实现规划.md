# LDIMS 新功能实现规划

本文档基于 `新功能规划.md`，旨在为 LDIMS 系统新增的多项核心功能（多文件支持、智能内容提取、可配置存储、MCP 服务器接口）提供一个分阶段、详细的实现计划。

**实施优先级:**

1.  **核心多文件上传与管理功能 (异步流程)**
2.  **后台内容提取 (MarkItDown & PaddleOCR) 与展示 (注意：提取内容仅用于 LLM)**
3.  **独立 MCP 服务器实现与 LLM 集成接口**

---

## 阶段一：核心多文件上传与管理功能 (异步流程)

**目标:** 实现用户先创建文档元数据，然后可以异步、分批（但遵循整体替换原则）上传关联文件，并手动触发后续处理。此阶段**不包含**实际的内容提取处理，但**前端展示**需要按最终效果设计（预览原始文件）。

**1. 数据库准备 (必需最先完成):**

- ✅ **执行 SQL 变更:**
  - 在数据库中执行 `新功能规划.md` 中定义的 SQL 操作指令：
    - 创建 `document_files` 表 (包含 `sequence` 字段, `processing_status` 初始默认值改为 `pending`)。
    - 为 `document_files.extracted_content` 添加**全文索引**。
    - 向 `system_configs` 表插入 `FILE_STORAGE_PATH` 配置项。
  - **验证:** 确认表结构和配置项已正确创建。
  - _SQL 微调:_ `document_files` 的 `processing_status` 默认值改为 `pending`。
    ```sql
    -- ... 创建 document_files 表 ...
    `processing_status` ENUM('pending', 'processing', 'completed', 'failed', 'ocr_fallback') NOT NULL DEFAULT 'pending' COMMENT '内容处理状态',
    -- ... 其他不变 ...
    ```

**2. 后端 (LDIMS 核心) 实现:**

- ✅ **模型层更新:**
  - 使用 Sequelize CLI 或手动创建 `DocumentFile` 模型 (`src/models/DocumentFile.ts`)，包含 `新功能规划.md` 中定义的所有字段 (`id`, `document_id`, `file_name`, `file_path`, `file_type`, `file_size`, `sequence`, `extracted_content`, `processing_status`, `created_at`, `updated_at`)。
  - 定义 `Document` 与 `DocumentFile` 的一对多关联 (`Document.hasMany(DocumentFile)`) 和反向关联 (`DocumentFile.belongsTo(Document)`)。
  - 确保关联在 `models/index.ts` 中被正确调用/定义。
- ✅ **配置读取与存储逻辑:**
  - 实现读取 `system_configs` 表中 `FILE_STORAGE_PATH` 的逻辑（例如，在 `src/config/storage.ts` 或类似模块中）。提供安全的默认路径。
  - 配置 `multer` 中间件 (`src/middleware/documentUpload.ts`):
    - 使用配置好的存储路径作为根目录 (`getDocumentStoragePath`)。
    - 配置 `multer.diskStorage`：目标目录为 `[根路径]/[净化后的文档名]/` (需要动态生成)，文件名先使用临时唯一名 (如 UUID)。
    - 配置 `multer.array('files', ...)`。
    - 设置合理的文件大小和类型限制。
- ✅ **API 端点实现/修改:**
  - ✅ **`POST /api/v1/documents` (创建文档元数据):**
    - ✅ 定义路由 (`src/routes/document.ts`)。
    - ✅ 实现控制器函数 (`src/controllers/documentController.ts#createDocumentMetadata`)。
    - ✅ 应用认证/权限中间件。
    - ✅ 添加请求体验证 (JSON, 必须字段如 `docName`, `submitter`, `receiver` 等)。
    - ✅ 调用 `DocumentService.createDocument` 方法 (传递元数据和 `req.user.name` 或类似的用户信息)。
    - ✅ 处理服务层错误 (如验证失败、数据库错误)。
    - ✅ 成功时返回 201 状态码和创建的文档信息 (包含 ID)。
  - ✅ **`PUT /api/v1/documents/:id` (更新文档元数据):**
    - ✅ 定义路由。
    - ✅ 实现控制器函数 (`src/controllers/documentController.ts#updateDocumentMetadata`)。
    - ✅ 应用认证/权限中间件。
    - ✅ 添加路径参数 (`id`) 和请求体验证。
    - ✅ 调用 `DocumentService.updateDocument` 方法 (传递 ID, 元数据, `req.user.name`)。
    - ✅ 处理服务层错误 (如文档未找到、验证失败)。
    - ✅ 成功时返回 200 状态码和更新后的文档信息。
  - ✅ **`POST /api/v1/documents/:id/files` (上传/替换关联文件):**
    - ✅ 定义路由。
    - ✅ 实现控制器函数 (`src/controllers/documentController.ts#uploadDocumentFiles`)。
    - ✅ 应用认证/权限中间件。
    - ✅ **应用 `documentUploadMiddleware` 处理 `multipart/form-data` 和 'files' 字段。**
    - ✅ 添加路径参数 (`id`) 验证 (确保是数字)。
    - ✅ 检查 `req.files` 是否存在且为数组 (Multer 会处理空上传，但最好确认)。
    - ✅ **调用 `DocumentService.uploadAndReplaceFiles` 方法 (传递 `id` 和 `req.files` 数组)。**
    - ✅ 处理服务层错误 (如文档未找到、文件保存/删除失败、数据库事务错误)。
    - ✅ 处理 Multer 中间件可能产生的错误 (如文件过大、类型不符 - 通过全局错误处理或在此捕获)。
    - ✅ 成功时返回 200 状态码和新文件列表信息 (或仅成功消息)。
  - ✅ **`(可选) DELETE /api/v1/documents/:id/files` (清空关联文件):**
    - ✅ 决定是否实现此端点 (已决定实现)。
    - ✅ 定义路由 (如果实现)。
    - ✅ 实现控制器函数 (`DocumentController.ts#deleteAllDocumentFiles`) (如果实现)。
    - ✅ 应用认证/权限中间件 (如果实现)。
    - ✅ 添加路径参数 (`id`) 验证 (如果实现)。
    - ✅ 调用 `DocumentService.deleteAllFilesForDocument` 方法 (传递 `id`) (如果实现)。
    - ✅ 处理服务层错误 (如文档未找到) (如果实现)。
    - ✅ 成功时返回 204 (No Content) 或 200 状态码 (如果实现)。
  - ✅ **`POST /api/v1/documents/:id/start-processing` (触发文件处理):**
    - ✅ 定义路由。
    - ✅ 实现控制器函数 (`src/controllers/DocumentController.ts#startFileProcessing`)。
    - ✅ 应用认证/权限中间件。
    - ✅ 添加路径参数 (`id`) 验证。
    - ✅ 调用 `DocumentService.triggerFileProcessing` 方法 (传递 `id`)。
    - ✅ 处理服务层错误 (如文档未找到、任务入队失败)。
    - ✅ 成功时返回 202 (Accepted) 或 200 状态码，表示处理已接受/开始。
  - ✅ **`GET /api/v1/files/:file_id/download` (下载单个文件):**
    - ✅ 定义路由。
    - ✅ 实现控制器函数 (`src/controllers/DocumentController.ts#downloadDocumentFile`)。
    - ✅ 应用认证/权限中间件。
    - ✅ 添加路径参数 (`file_id`) 验证。
    - ✅ 调用服务层方法获取文件信息 (如 `DocumentFile.findByPk(file_id)`)，包含 `filePath` (相对路径) 和 `fileName` (原始文件名)。
    - ✅ 处理文件记录未找到的错误 (返回 404)。
    - ✅ 使用 `getStoragePath` 获取存储根路径。
    - ✅ 使用存储根路径和 `filePath` 拼接完整的文件物理路径。
    - ✅ 使用 `res.download()` 提供文件下载，传递完整物理路径和**原始文件名 (`fileName`)**。
    - ✅ 处理读取物理文件时的错误 (返回 500)。
  - ✅ **`PUT /api/v1/system/config` (更新系统配置 - 确保兼容):**
    - ✅ 检查现有系统配置路由 (`src/routes/system.ts`) 和控制器 (`src/controllers/systemController.ts`)。
    - ✅ 确保应用了合适的管理员权限中间件。
    - ✅ 确认或添加请求体验证（检查 `configKey` 和 `configValue`）。
    - ✅ 调用 `SystemConfigService` (或直接在控制器中) 更新或创建配置项。
    - ✅ **添加逻辑:** 如果更新的 `configKey` 是 `FILE_STORAGE_PATH`，则调用 `clearCachedStoragePaths()` (来自 `src/config/storage.ts`)。
    - ✅ 处理错误。
    - ✅ 返回成功响应。
- ✅ **服务层 (`DocumentService`) 调整:**
  - ✅ **调整 `getDocumentById` 方法:**
    - ✅ 修改查询，使用 `include` 选项 (Eager Loading) 加载关联的 `DocumentFile` 模型。
    - ✅ 确保关联的 `DocumentFile` 按 `sequence` 字段升序排列。
  - ✅ **调整 `listDocuments` 方法:**
    - ✅ 分析前端列表页是否需要关联文件的聚合信息（数量）。
    - ✅ 修改查询以包含关联文件数量 (`fileCount`)。

**3. 前端 (LDIMS Vue App) 实现:**

- ✅ **API 服务层 (`src/services/api/document.ts`):**

  - ✅ 更新 `createDocument` 和 `updateDocument` 方法签名和实现以匹配后端 API (确认无需修改)。
  - ✅ 新增 `uploadFiles(documentId, formData)` 方法。
  - ✅ 新增 `deleteAllFiles(documentId)` 方法。
  - ✅ 新增 `startProcessing(documentId)` 方法。
  - ✅ 新增 `downloadFile(fileId)` 方法 (并实现 `downloadBlob` 辅助函数)。

- [ ] **文档创建/编辑流程调整 (`components/DocumentFormDialog.vue` 或类似组件):**

  - [ ] **状态管理:** 添加用于存储当前 `documentId` (创建成功后) 和关联文件列表 (`files`) 的响应式状态。
  - [ ] **步骤 1: 保存元数据:**
    - [ ] 修改 `handleSave` 或类似方法：
      - 仅提交文档元数据 (调用 `create/updateDocument` API)。
      - 成功后，保存返回的 `documentId` (如果是创建)。
      - 调用 API 获取最新的文档详情 (包含 `files`) 并更新本地状态。
      - 设置标志位以启用文件管理区域。
  - [ ] **步骤 2: 文件管理区域 (条件渲染):**
    - [ ] 根据标志位 (例如 `isMetadataSaved` 或 `documentId !== null`) 控制文件管理区域的显示/启用。
    - [ ] **显示当前文件列表 (`el-table` 或类似):**
      - [ ] 使用本地状态中的 `files` 数组作为数据源。
      - [ ] 展示列：序号 (`sequence`)、文件名 (`fileName`)、类型 (`fileType`)、大小 (`fileSize` - 格式化)、状态 (`processingStatus` - 格式化为中文)、创建/更新时间 (格式化)。
      - [ ] 为每行添加"下载"按钮，点击调用 `downloadFile(file.id)` API。
    - [ ] **上传组件 (`el-upload`):**
      - [ ] 配置 `action` 指向 `POST /api/v1/documents/:id/files` (动态绑定 `:id`)。
      - [ ] 设置 `:headers` 以包含认证 Token。
      - [ ] 设置 `multiple=true` 允许多选。
      - [ ] 设置 `:limit` 以匹配后端限制 (`MAX_FILES_PER_UPLOAD`)。
      - [ ] **禁用 `:auto-upload`**，我们需要手动触发。
      - [ ] 实现 `:on-change` 或类似事件处理，将被选文件列表保存到本地状态 (e.g., `filesToUpload`)。
      - [ ] 实现 `:on-exceed` 处理超出数量限制的情况。
      - [ ] 添加 `:before-upload` (可选) 进行前端文件类型/大小校验。
      - [ ] 添加 `<template #tip>` 显示提示信息 ("上传新文件将替换...")。
    - [ ] **手动上传触发:**
      - [ ] 添加"上传选中文件"按钮 (仅在 `filesToUpload` 不为空时启用)。
      - [ ] 点击按钮时：
        - 创建 `FormData` 对象。
        - 遍历 `filesToUpload` 将文件添加到 `FormData`。
        - 调用 `uploadFiles(documentId, formData)` API。
        - 处理上传成功/失败，成功后清空 `filesToUpload` 并刷新文件列表。
    - [ ] **(可选) 清空按钮:**
      - [ ] 添加"清空所有文件"按钮 (仅在 `files` 列表不为空时启用)。
      - [ ] 添加确认对话框 (`ElMessageBox.confirm`)。
      - [ ] 确认后，调用 `deleteAllFiles(documentId)` API。
      - [ ] 处理成功/失败，成功后刷新文件列表。
    - [ ] **处理按钮:**
      - [ ] 添加"开始处理文件"按钮。
      - [ ] 根据 `files` 列表中是否存在 `processingStatus` 为 `'pending'` 的文件来控制按钮的启用/禁用状态。
      - [ ] 点击按钮时，调用 `startProcessing(documentId)` API。
      - [ ] 处理成功/失败，成功后可能需要更新文件列表的状态 (或提示用户等待后台处理)。

- [ ] **内容展示 (Tabs - 在 `DocumentFormDialog.vue` 或新组件中):**

  - [ ] **引入 `<el-tabs>` 组件:** 将其放置在元数据表单下方或一个独立的区域。
  - [ ] **动态生成 Tabs:**
    - [ ] 使用 `v-for` 遍历文档详情中的 `files` 数组。
    - [ ] 每个 `<el-tab-pane>` 的 `label` 设为 `file.fileName`，`name` 设为 `file.id` 或 `file.sequence`。
  - [ ] **每个 Tab Pane 内容:**
    - [ ] 显示文件元数据：类型 (`file.fileType`)、大小 (`file.fileSize` - 格式化)。
    - [ ] 显示处理状态 (`file.processingStatus` - 格式化为中文)。
    - [ ] 添加该文件的**独立下载按钮**，点击调用 `downloadFile(file.id)`。
    - [ ] **文件预览/访问区域 (根据 `file.fileType` 条件渲染):**
      - [ ] **图片 (jpg, png):**
        - [ ] 使用 `<el-image>` 组件，`src` 指向下载 API (`/api/v1/files/${file.id}/download`) 或一个专门的预览 API。
        - [ ] 配置 `:preview-src-list` 实现点击放大预览。
      - [ ] **PDF:**
        - [ ] 显示一个 `<el-link>` 或 `<el-button>`，文本为 "在新标签页打开 PDF"。
        - [ ] `href` 指向下载 API (`/api/v1/files/${file.id}/download`) 并添加 `target="_blank"`。
      - [ ] **Office 文档 (docx, xlsx, pptx 等):**
        - [ ] 显示提示文本 `<span>此文件类型不支持在线预览，请下载查看。</span>`。
      - [ ] **其他未知类型:** (可选) 显示通用提示或仅下载按钮。

- [ ] **文档列表页 (`views/DocumentListView.vue`):**
  - [ ] **修改表格列定义 (`<el-table-column>`):**
    - [ ] 移除旧的单一文件相关列 (如果存在)。
    - [ ] 保留 "文档名称" 等核心元数据列。
    - [ ] **新增 "关联文件" 列:**
      - [ ] 使用 `prop="fileCount"` 或自定义模板。
      - [ ] 在模板中，读取行数据 (`row.fileCount`)。
      - [ ] 显示类似 "{row.fileCount} 个文件" 的文本。
      - [ ] **(可选) 添加状态图标:** 根据后端未来可能提供的聚合状态字段，显示 ✅/⏳/❌ 图标。
      - [ ] 将单元格内容（例如文件数量文本）包装在 `<el-link>` 或可点击元素中。
      - [ ] 绑定点击事件，调用打开详情弹窗/视图的方法，并传递 `row.id`。

---

## 阶段二：后台内容提取 (MarkItDown & PaddleOCR) 与展示 (注意：提取内容仅用于 LLM)

**目标:** 实现对上传的每个文件进行后台智能内容提取，**并将结果存储在 `document_files.extracted_content` 字段中，供后续 LLM 使用**。前端**不直接展示**这部分内容。

**1. 后端 (LDIMS 核心) 实现:**

- [ ] **后台任务队列与处理器:**
  - 确认或实现一个健壮的任务队列机制 (当前为 `TaskQueueService`，可考虑换用 `bullmq` 等库以获得更好的并发控制、重试等功能)。
  - 实现任务处理器逻辑，能够根据 `task_type` (`content_extraction`) 调用正确的处理函数。
  - 实现并发控制，限制同时运行的 Python 进程数量。
- [ ] **Node.js <-> Python 交互层:**
  - 创建一个通用的函数/模块 (e.g., `src/utils/pythonExecutor.ts`) 来处理 `child_process.spawn` 的调用：
    - 安全地构造 Python 脚本路径和命令行参数 (文件路径等)。
    - 捕获 Python 脚本的 `stdout` (结果) 和 `stderr` (错误)。
    - 处理进程退出码和错误事件。
    - 设置超时机制。
- [ ] **内容提取服务逻辑 (`ContentProcessingService` 或在 `TaskQueueService` 中):**
  - 实现 `processContentExtractionTask(fileInfo: DocumentFile)` 函数：
    - 根据 `fileInfo.file_type` 判断文件类型。
    - 获取文件的完整物理路径。
    - **调用交互层执行 Python 脚本:**
      - **图片 (JPG, PNG):** 调用 PaddleOCR Python 脚本。
      - **Word (DOCX):** 调用 MarkItDown Python 脚本。
      - **PDF:**
        - 优先调用 MarkItDown Python 脚本。
        - 检查 MarkItDown 返回结果是否有效 (不为空，长度足够等)。
        - 若无效，触发 OCR Fallback:
          - **(方案 A: Node 端转图片)** 调用 `pdf-poppler` 将 PDF 转为图片 (临时文件)。
          - 调用 PaddleOCR Python 脚本处理图片。
          - 清理临时图片。
          - **(方案 B: Python 端转图片)** 直接调用 PaddleOCR Python 脚本，脚本内部使用 `PyMuPDF` 等库转换 PDF。
      - **(PDF 预处理 - 如果方案 A):** 实现 Node.js 端使用 `pdf-poppler` 转换 PDF 页面的逻辑。
    - **处理结果:**
      - 成功时，将返回的 Markdown 或文本更新到 `document_files.extracted_content`，状态更新为 `completed`。
      - 失败时，记录错误信息，状态更新为 `failed`。
- [ ] **完善 `start-processing` API:** 确保它能正确地将任务添加到队列中。

**2. Python 环境与脚本:**

- [ ] **环境搭建:**
  - 在服务器上安装兼容的 Python 版本。
  - 创建虚拟环境 (推荐)。
  - 安装所需库: `paddleocr`, `paddlepaddle` (CPU 或 GPU 版), `markitdown`

**3. 前端 (LDIMS Vue App) 实现:**

- [ ] **内容展示 (弹窗/详情页):** **无需变更**。前端在此阶段只需正确显示在阶段一已完成的元数据、下载按钮和预览/访问方式。处理状态 (`processing_status`) 会根据后台任务自动更新。
- [ ] **列表页 (`views/DocumentListView.vue`):** 确保"关联文件"列的聚合状态能正确反映各个文件的 `processing_status`。

---

## 阶段三：独立 MCP 服务器实现与 LLM 集成接口

**目标:** (同前)

**1. 后端 (LDIMS 核心) 实现:** (同前，确保内部 API 正确返回包括 `extracted_content` 在内的数据)

**2. MCP 服务器 (独立 Node.js/TypeScript 项目) 实现:** (同前，能力处理函数调用内部 API 获取数据，特别是 `extracted_content`)

**3. 部署:** (同前)

---

## 贯穿各阶段的任务

- **测试:** (同前，增加对文件存储结构、命名、截断、下载文件名的测试)
- **错误处理:** (同前，增加文件名处理、文件重命名、文件夹操作相关的错误处理)
- **文档:** (同前，更新存储和命名约定)
- **安全性:** (同前，确保文件名净化和路径处理的安全性)
