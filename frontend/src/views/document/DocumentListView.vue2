<script setup lang="ts">
// 关键诊断日志: 确认脚本是否开始执行
console.log('[DocumentListView] Script setup STARTING...');

// 0. Add top-level log
console.log('[DocumentListView] Script setup executing...');

// --- Vue and Element Plus Imports ---
import { ref, reactive, onMounted, computed } from 'vue'
import type { ComponentPublicInstance } from 'vue';
import { ElMessage, ElMessageBox } from 'element-plus'

// --- API Service Imports ---
import {
  getDocuments,
  deleteDocument,
} from '@/services/api/document'
import { getDepartmentList } from '@/services/api/department'
import { getDocTypeList } from '@/services/api/doctype'
import { requestImport } from '@/services/api/task'
import type { ImportRequestParams } from '@/types/export'
import type { DocumentInfo, DocumentListQuery } from '@backend-types/document'
import type { DepartmentInfo } from '@backend-types/department'
import type { DocTypeInfo } from '@backend-types/doctype'

// --- Utility and Component Imports ---
import DocumentFormDialog from '@/components/DocumentFormDialog.vue'
import ImportDialog from '@/components/ImportDialog.vue'
import { Search, Refresh, Plus, Upload, Download, View, Edit, Delete } from '@element-plus/icons-vue'

// --- 新增：简单的日期格式化函数 ---
/**
 * @description 格式化日期时间用于显示。
 * @param {string | number | Date | undefined | null} dateInput 日期输入。
 * @param {boolean} [onlyDate=false] 是否只显示日期部分。
 * @returns {string} 格式化后的日期字符串，如果输入无效则返回 '-'。
 */
const formatDisplayDate = (dateInput: string | number | Date | undefined | null, onlyDate: boolean = false): string => {
  if (!dateInput) return '-';
  try {
    const date = new Date(dateInput);
    if (isNaN(date.getTime())) return '-'; // 无效日期
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    if (onlyDate) return `${year}-${month}-${day}`;
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    const seconds = date.getSeconds().toString().padStart(2, '0');
    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  } catch (error) {
    console.error('Error formatting date:', dateInput, error);
    return '-';
  }
};
// --- 结束：简单的日期格式化函数 ---

// --- Search Parameters --- (恢复 DocumentListQuery 类型)
const searchParams = reactive<Partial<DocumentListQuery>>({
  docName: '',
  submitter: '',
  receiver: '',
  signer: '',
  handoverStartDate: undefined,
  handoverEndDate: undefined,
  page: 1,
  pageSize: 10,
  docTypeName: '',
  departmentName: '',
})

// --- Data and State Refs --- (恢复 DocumentInfo 类型)
const docTypeList = ref<DocTypeInfo[]>([]) // 恢复 DocTypeInfo[]
const departmentList = ref<DepartmentInfo[]>([]) // 恢复 DepartmentInfo[]
const loading = ref(false)
const tableData = ref<DocumentInfo[]>([]) // 恢复 DocumentInfo[]
const total = ref(0)
const documentFormDialogRef = ref<any>(null) // 保持 any，等待子组件类型修复
const importDialogRef = ref<InstanceType<typeof ImportDialog> | null>(null);

// --- Data Fetching Functions ---

/**
 * @description 获取文档类型列表。
 */
const fetchDocTypes = async () => {
  try {
    // getDocTypeList 返回 { list: DocTypeInfo[], total: number }
    const res = await getDocTypeList({ page: 1, pageSize: 999 }) // 假设仍可接受分页参数
    // 直接使用返回的 list
    if (res && Array.isArray(res.list)) {
      docTypeList.value = res.list
    } else {
      console.error('Invalid response structure from getDocTypeList:', res);
      ElMessage.error('获取文档类型列表失败: 响应格式错误')
      docTypeList.value = []
    }
    // 不再需要检查 res.code 或 res.data
    // if (res?.code === 0 && res?.data?.list) { ... } else { ... }
  } catch (error) {
    console.error('获取文档类型列表失败:', error)
    ElMessage.error('获取文档类型列表时发生网络或服务器错误')
    docTypeList.value = []
  }
}

/**
 * @description 获取部门列表。
 */
const fetchDepartments = async () => {
  try {
    // getDepartmentList 返回 DepartmentInfo[]
    const res = await getDepartmentList();
    if (Array.isArray(res)) {
       departmentList.value = res;
    } else {
       console.error("Unexpected response structure from getDepartmentList:", res);
       ElMessage.error('获取部门列表失败: 响应格式错误');
       departmentList.value = [];
    }
    // 不再需要显式使用 any
    // const res: any = await getDepartmentList();
  } catch (error) {
    console.error('获取部门列表失败:', error);
    ElMessage.error('获取部门列表时发生网络或服务器错误');
     departmentList.value = [];
  }
}

/**
 * @description 获取文档列表。
 */
const fetchDocuments = async () => {
  loading.value = true;
  try {
    const params: Partial<DocumentListQuery> = { // 恢复 DocumentListQuery
        page: searchParams.page,
        pageSize: searchParams.pageSize
    };
    if (searchParams.docName) params.docName = searchParams.docName;
    if (searchParams.submitter) params.submitter = searchParams.submitter;
    if (searchParams.receiver) params.receiver = searchParams.receiver;
    if (searchParams.signer) params.signer = searchParams.signer;
    if (searchParams.departmentName) params.departmentName = searchParams.departmentName;
    if (searchParams.docTypeName) params.docTypeName = searchParams.docTypeName;
    if (searchParams.handoverStartDate) params.handoverStartDate = formatDisplayDate(searchParams.handoverStartDate, true);
    if (searchParams.handoverEndDate) params.handoverEndDate = formatDisplayDate(searchParams.handoverEndDate, true);

    const res = await getDocuments(params);

    if (res && Array.isArray(res.list)) {
        tableData.value = res.list;
        total.value = res.total ?? 0;
    } else {
        console.error('Invalid response structure from getDocuments:', res);
        tableData.value = [];
        total.value = 0;
        ElMessage.error('获取文档列表失败: 响应格式错误');
    }
  } catch (error) {
      console.error('Error fetching documents: ', error);
       ElMessage.error('获取列表时发生网络或服务器错误');
       tableData.value = [];
       total.value = 0;
  } finally {
    loading.value = false;
  }
}

// --- UI Event Handlers ---

/**
 * @description 重置搜索表单。
 */
const handleReset = () => {
  searchParams.docName = ''
  searchParams.submitter = ''
  searchParams.receiver = ''
  searchParams.signer = ''
  searchParams.handoverStartDate = undefined
  searchParams.handoverEndDate = undefined
  searchParams.docTypeName = ''
  searchParams.departmentName = ''
  searchParams.page = 1 // 重置到第一页
  fetchDocuments() // 重新获取数据
}

/**
 * @description 处理搜索按钮点击。
 */
const handleSearch = () => {
  searchParams.page = 1 // 搜索时回到第一页
  fetchDocuments()
}

/**
 * @description 处理每页显示条数变化。
 * @param {number} val 新的每页显示条数。
 */
const handleSizeChange = (val: number) => {
  searchParams.pageSize = val
  searchParams.page = 1 // 条数变化时回到第一页
  fetchDocuments()
}

/**
 * @description 处理当前页码变化。
 * @param {number} val 新的当前页码。
 */
const handleCurrentChange = (val: number) => {
  searchParams.page = val
  fetchDocuments()
}

/**
 * @description 处理新增按钮点击，打开表单。
 */
const handleAdd = () => {
  // 传递 null 表示新增 (根据之前的Linter错误)
  documentFormDialogRef.value?.open(null)
}

/**
 * @description 处理编辑按钮点击，打开表单并传入文档ID。
 * @param {DocumentInfo} row 当前行数据 (恢复类型)。
 */
const handleEdit = (row: DocumentInfo) => {
  documentFormDialogRef.value?.open(row.id)
}

/**
 * @description 处理删除按钮点击。
 * @param {DocumentInfo} row 当前行数据 (恢复类型)。
 */
const handleDelete = (row: DocumentInfo) => {
  ElMessageBox.confirm(`确定要删除文档 "${row.docName}" 吗？`, '提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning',
  })
    .then(async () => {
      loading.value = true;
      try {
        await deleteDocument(row.id)
        ElMessage.success('删除成功')
        if (tableData.value.length === 1 && searchParams.page && searchParams.page > 1) {
          searchParams.page -= 1
        }
        fetchDocuments()
      } catch (error) {
        console.error('删除文档失败:', error)
        let errorMsg = '删除文档时发生错误';
        if (error instanceof Error) {
          const axiosError = error as any;
          if (axiosError.response?.data?.message) {
            errorMsg = axiosError.response.data.message;
          } else {
            errorMsg = error.message;
          }
        }
        ElMessage.error(errorMsg);
      } finally {
        loading.value = false;
      }
    })
    .catch(() => {
      // 用户取消操作，不做处理
      // ElMessage.info('已取消删除')
    })
}

/**
 * @description 处理查看按钮点击（功能待实现）。
 * @param {DocumentInfo} row 当前行数据 (恢复类型)。
 */
const handleView = (row: DocumentInfo) => {
  console.log('查看文档:', row)
  ElMessage.info('查看功能待实现')
  // 后续可以实现跳转到详情页或弹出详情模态框
}

/**
 * @description 处理"批量导入"按钮点击，改为打开对话框
 */
const handleImportClick = async () => {
  console.log('[DocumentListView] handleImportClick called');
  try {
    console.log('[DocumentListView] Checking importDialogRef...');
    if (!importDialogRef.value) {
      console.error('[DocumentListView] Import dialog reference is null. Component might not be mounted or ref is not set correctly.');
      ElMessage.error('无法获取导入对话框组件的引用');
      return;
    }
    console.log('[DocumentListView] importDialogRef found:', importDialogRef.value);
    if (typeof importDialogRef.value.open !== 'function') {
       console.error("[DocumentListView] 'open' method does not exist on the importDialogRef. Check expose in ImportDialog.vue.");
       ElMessage.error("导入对话框组件缺少必要的 'open' 方法。");
       return;
    }
    console.log('[DocumentListView] Calling importDialogRef.value.open()...');
    await importDialogRef.value.open();
    console.log('[DocumentListView] Called importDialogRef.value.open() successfully.');
  } catch (error) {
    console.error('[DocumentListView] Error opening import dialog:', error);
    ElMessage.error('打开导入对话框时发生未知错误');
  }
};

// --- Lifecycle Hook ---

/**
 * @description 组件挂载后执行初始化操作。
 */
onMounted(() => {
  // 添加 onMounted 开始日志
  console.log('[DocumentListView] onMounted STARTING...');
  fetchDocTypes()     // 获取文档类型
  fetchDepartments()  // 获取部门列表
  fetchDocuments()    // 获取初始文档列表
})
</script>

<template>
  <div class="document-list-view">
    <!-- 搜索区域 -->
    <el-card shadow="never">
      <el-form :inline="true" :model="searchParams" class="search-form" label-width="70px">
        <el-form-item label="文档名称">
          <el-input v-model="searchParams.docName" placeholder="输入文档名称" clearable />
        </el-form-item>
        <el-form-item label="提交人">
          <el-input v-model="searchParams.submitter" placeholder="输入提交人" clearable />
        </el-form-item>
        <el-form-item label="接收人">
          <el-input v-model="searchParams.receiver" placeholder="输入接收人" clearable />
        </el-form-item>
        <el-form-item label="文档类型">
          <el-select v-model="searchParams.docTypeName" placeholder="选择或输入文档类型" clearable filterable allow-create style="width: 180px">
            <el-option v-for="item in docTypeList" :key="item.id" :label="item.name" :value="item.name" />
          </el-select>
        </el-form-item>
        <el-form-item label="来源部门">
           <el-select v-model="searchParams.departmentName" placeholder="选择或输入来源部门" clearable filterable allow-create style="width: 180px">
             <el-option v-for="item in departmentList" :key="item.id" :label="item.name" :value="item.name" />
           </el-select>
        </el-form-item>
        <el-form-item label="签收人">
          <el-input v-model="searchParams.signer" placeholder="输入签收人" clearable />
        </el-form-item>
         <el-form-item label="交接日期">
             <el-date-picker v-model="searchParams.handoverStartDate" type="date" placeholder="开始日期" value-format="YYYY-MM-DD" style="width: 140px;" />
            <span style="margin: 0 5px;">至</span>
             <el-date-picker v-model="searchParams.handoverEndDate" type="date" placeholder="结束日期" value-format="YYYY-MM-DD" style="width: 140px;" />
        </el-form-item>
        <el-form-item class="search-buttons">
          <el-button type="primary" @click="handleSearch"><el-icon><Search /></el-icon>搜索</el-button>
          <el-button @click="handleReset"><el-icon><Refresh /></el-icon>重置</el-button>
        </el-form-item>
      </el-form>
    </el-card>

    <!-- 操作栏和表格区域 -->
    <el-card shadow="never" style="margin-top: 15px;">
       <!-- 工具栏 -->
       <div class="toolbar" style="align-items: flex-start;">
         <!-- 新增文档按钮 -->
         <el-button type="primary" @click="handleAdd">
           <el-icon><Plus /></el-icon> 新增文档
         </el-button>

         <!-- 批量导入按钮 - 点击打开对话框 -->
         <el-button type="success" @click="handleImportClick">
           <el-icon><Upload /></el-icon> 批量导入
         </el-button>

         <!-- 导出按钮 (暂时禁用) -->
         <el-button type="warning" disabled>
           <el-icon><Download /></el-icon> 导出
         </el-button>
      </div>

       <!-- 文档数据表格 -->
       <el-table :data="tableData" v-loading="loading" style="width: 100%; margin-top: 15px;" border stripe>
         <!-- 列定义 -->
         <el-table-column type="selection" width="55" align="center" />
         <el-table-column prop="id" label="ID" width="80" align="center" sortable />
         <el-table-column prop="docName" label="文档名称" min-width="250" show-overflow-tooltip sortable />
         <el-table-column prop="docTypeName" label="文档类型" width="150" align="center" />
         <el-table-column prop="departmentName" label="来源部门" width="150" align="center" />
         <el-table-column prop="submitter" label="提交人" width="120" align="center" />
         <el-table-column prop="receiver" label="接收人" width="120" align="center" />
         <el-table-column prop="signer" label="签收人" width="120" align="center" />
         <el-table-column prop="handoverDate" label="交接日期" width="130" align="center" sortable>
             <template #default="{ row }">
                <!-- 使用新的本地格式化函数，只显示日期 -->
                {{ formatDisplayDate(row.handoverDate, true) }}
            </template>
         </el-table-column>
         <el-table-column prop="createdByName" label="创建人" width="120" align="center" />
         <el-table-column prop="createdAt" label="创建时间" width="170" align="center" sortable>
           <template #default="{ row }">
             <!-- 使用新的本地格式化函数，显示完整日期时间 -->
             {{ formatDisplayDate(row.createdAt) }}
           </template>
         </el-table-column>
         <!-- 操作列 -->
         <el-table-column label="操作" width="180" align="center" fixed="right">
           <template #default="{ row }">
             <el-button type="primary" link size="small" @click="handleView(row)">
                <el-icon><View /></el-icon>查看
             </el-button>
             <el-button type="warning" link size="small" @click="handleEdit(row)">
                <el-icon><Edit /></el-icon>编辑
             </el-button>
             <el-button type="danger" link size="small" @click="handleDelete(row)">
               <el-icon><Delete /></el-icon>删除
             </el-button>
           </template>
         </el-table-column>
       </el-table>

       <!-- 分页组件 -->
       <el-pagination
         v-if="total > 0"
         style="margin-top: 15px; justify-content: flex-end;"
         :current-page="searchParams.page"
         :page-size="searchParams.pageSize"
         :page-sizes="[10, 20, 50, 100]"
         :total="total"
         layout="total, sizes, prev, pager, next, jumper"
         @size-change="handleSizeChange"
         @current-change="handleCurrentChange"
       />
    </el-card>

    <!-- 新增/编辑文档的表单组件 -->
    <DocumentFormDialog
      ref="documentFormDialogRef"
      :doc-type-tree-data="docTypeList"
      :department-tree-data="departmentList"
      @success="fetchDocuments"
     />

    <!-- 新增：导入文件对话框 -->
    <ImportDialog ref="importDialogRef" />

  </div>
</template>

<style lang="scss" scoped>
.search-form {
  display: flex;
  flex-wrap: wrap; // 允许换行
  gap: 15px; // Flex项目之间的水平间距
  row-gap: 10px; // Flex项目之间的垂直间距（需要浏览器支持）
  align-items: center; // 垂直居中对齐
  .el-form-item {
     margin-bottom: 0; // 移除默认的底部外边距
  }
  .search-buttons {
     margin-left: 10px; // 搜索按钮组左侧留出间距
  }
}
.toolbar {
  margin-bottom: 15px; // 工具栏下方留出间距
  display: flex;
  justify-content: flex-start; // 按钮靠左对齐
  gap: 10px; // 按钮之间的间距
}
</style>